// Code generated by gop (Go+); DO NOT EDIT.

package main

import (
	"fmt"
	"github.com/goplus/cobra/xcmd"
)

const _ = true

type Cmd_backward struct {
	xcmd.Command
	*godemo
}
type godemo struct {
	xcmd.App
}
type Cmd_mod struct {
	xcmd.Command
	*godemo
}
type Cmd_mod_init struct {
	xcmd.Command
	*godemo
	LLGo    bool `flag:"llgo, val: true, usage: use LLGo as underlying compiler"`
	Verbose bool `flag:"verbose, short: v, usage: print verbose information"`
}
type Cmd_version struct {
	xcmd.Command
	*godemo
	Verbose bool `flag:"verbose, short: v, usage: print verbose information"`
}
//line xcmd/demo/godemo/godemo_app.gox:1
func (this *godemo) MainEntry() {
//line xcmd/demo/godemo/godemo_app.gox:1:1
	this.Short("godemo is a cobra xcmd demo")
}
func (this *godemo) Main() {
	_gop_obj0 := &Cmd_backward{godemo: this}
	_gop_obj1 := &Cmd_mod{godemo: this}
	_gop_obj2 := &Cmd_mod_init{godemo: this}
	_gop_obj3 := &Cmd_version{godemo: this}
	xcmd.Gopt_App_Main(this, _gop_obj0, _gop_obj1, _gop_obj2, _gop_obj3)
}
//line xcmd/demo/godemo/backward_cmd.gox:1
func (this *Cmd_backward) Main(_gop_arg0 string) {
	this.Command.Main(_gop_arg0)
//line xcmd/demo/godemo/backward_cmd.gox:1:1
	this.FlagOff()
//line xcmd/demo/godemo/backward_cmd.gox:3:1
	this.Run__1(func(args []string) {
//line xcmd/demo/godemo/backward_cmd.gox:4:1
		fmt.Println("args:", args)
	})
}
func (this *Cmd_backward) Classfname() string {
	return "backward"
}
//line xcmd/demo/godemo/mod_cmd.gox:1
func (this *Cmd_mod) Main(_gop_arg0 string) {
	this.Command.Main(_gop_arg0)
//line xcmd/demo/godemo/mod_cmd.gox:1:1
	this.Short("module maintenance")
//line xcmd/demo/godemo/mod_cmd.gox:3:1
	this.Long(`Go mod provides access to operations on modules.

Note that support for modules is built into all the go commands,
not just 'go mod'. For example, day-to-day adding, removing, upgrading,
and downgrading of dependencies should be done using 'go get'.
See 'go help modules' for an overview of module functionality.
`)
//line xcmd/demo/godemo/mod_cmd.gox:11:1
	this.Run__0(func() {
//line xcmd/demo/godemo/mod_cmd.gox:12:1
		this.Help()
	})
}
func (this *Cmd_mod) Classfname() string {
	return "mod"
}
//line xcmd/demo/godemo/mod_init_cmd.gox:6
func (this *Cmd_mod_init) Main(_gop_arg0 string) {
	this.Command.Main(_gop_arg0)
//line xcmd/demo/godemo/mod_init_cmd.gox:6:1
	this.Short("initialize new module in current directory")
//line xcmd/demo/godemo/mod_init_cmd.gox:8:1
	this.Long(`Init initializes and writes a new go.mod file in the current directory, in
effect creating a new module rooted at the current directory. The go.mod file
must not already exist.

Init accepts one optional argument, the module path for the new module. If the
module path argument is omitted, init will attempt to infer the module path
using import comments in .go files, vendoring tool configuration files (like
Gopkg.lock), and the current directory (if in GOPATH).

If a configuration file for a vendoring tool is present, init will attempt to
import module requirements from it.

See https://golang.org/ref/mod#go-mod-init for more about 'go mod init'.
`)
//line xcmd/demo/godemo/mod_init_cmd.gox:23:1
	this.Run__1(func(args []string) {
//line xcmd/demo/godemo/mod_init_cmd.gox:24:1
		this.Printf("call go mod init %v: llgo=%v, verbose=%v\n", args, this.LLGo, this.Verbose)
	})
}
func (this *Cmd_mod_init) Classfname() string {
	return "mod_init"
}
//line xcmd/demo/godemo/version_cmd.gox:5
func (this *Cmd_version) Main(_gop_arg0 string) {
	this.Command.Main(_gop_arg0)
//line xcmd/demo/godemo/version_cmd.gox:5:1
	this.Short("print Go version")
//line xcmd/demo/godemo/version_cmd.gox:7:1
	this.Long(`Version prints the build information for Go binary files.

Go version reports the Go version used to build each of the named files.

If no files are named on the command line, go version prints its own
version information.

If a directory is named, go version walks that directory, recursively,
looking for recognized Go binaries and reporting their versions.
By default, go version does not report unrecognized files found
during a directory scan. The -v flag causes it to report unrecognized files.

The -m flag causes go version to print each file's embedded
module version information, when available. In the output, the module
information consists of multiple lines following the version line, each
indented by a leading tab character.

See also: go doc runtime/debug.BuildInfo.
`)
//line xcmd/demo/godemo/version_cmd.gox:27:1
	this.Run__0(func() {
//line xcmd/demo/godemo/version_cmd.gox:28:1
		fmt.Println("go1.0", "verbose:", this.Verbose)
	})
}
func (this *Cmd_version) Classfname() string {
	return "version"
}
func main() {
	new(godemo).Main()
}
